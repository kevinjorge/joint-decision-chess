{% extends "main/base.html" %}

{% load static %}

{% block title %}
Play
{% endblock %}

{% block style%}
<style>
    .homeblock {
        height: 5%;
    }

    .sidenav {
        height: 95%;
    }

    #iframe-container {
        position: relative;
        width: 100%;
    }
    #embedded-iframe {
        width: 100%;
    }

    .scrollable-moves-list {
        overflow-y: scroll;
        max-height: 40%; /* 10% above for the username later */
    }
    
    .action-button {
        border: none;
        outline: none;
        background-color: transparent;
        transition: background-color 0.3s ease;
        color: white;
    }

    .action-button:focus {
        outline: none;
    }

    .action-button.confirm.check {
        background-color: #6f9176;
    }

    .action-button.confirm:hover {
        background-color: #449255;
    }

    .action-button.confirm:disabled:hover {
        background-color: #da8525;
    }

    .action-button.cancel.check {
        background-color: rgb(161, 160, 85);
    }

    .action-button.cancel:hover {
        background-color: #a05139;
    }

    .hidden {
        display: none;
    }

    .move-row {
        display: flex;
    }

    .move-row > div {
        width: 50%;
    }

    .even-move-row {
        background-color: rgb(150, 150, 150);
    }
</style>
<script>
    var existingWebGameMetadata = localStorage.getItem('web_game_metadata');
    if (existingWebGameMetadata == null) {
        var webGameMetadata = {};
        localStorage.setItem('web_game_metadata', JSON.stringify(webGameMetadata));
    }
</script>
{% endblock %}

{% block content %}
<div id="content", name="content", class="content">
    <div class="row justify-content-center" style="max-width: 100%;"> <!-- max width necessary for no horizontal scrolling -->
        <!-- Given side bar maybe columns should instead be 3 5 3  and side bar width is a column width-->
        <!-- 3 columns for chat and notes -->
        <!-- Consider if this col-5 should be present for all play views or just the main one-->
        <!-- That is we can embedd the game itself in here as it's own template maybe -->
        <div class="col-5">
            <div id="iframe-container">
                <iframe id="embedded-iframe" src="{% static 'main/html/game.html' %}" frameborder=0 scrolling="no"></iframe>
            </div>
        </div>
        <!-- 3 columns for command center-->
        <div class="col-3 d-flex align-items-center">
            <div id="command-center" class="bg-secondary d-flex flex-column align-items-center justify-content-center" style="min-width: 100%;">
                <!-- Content will be dynamically added here -->
                <div id="moves-list" class="scrollable-moves-list" style="min-width: 100%;">
                    <!-- Content will be dynamically added here -->
                </div>
                <div id="final-score" class="text-white font-weight-bold text-lg mt-2"></div>
                <div id="end-message" class="text-white"></div>
                <div class="d-flex justify-content-center">
                    <!-- Need a button class here -->
                    <button id="undoOfferButton" actions="true" class="action-button confirm mr-2">Undo</button>
                    <button id="undoOfferConfirmButton" followup="true" class="action-button confirm check hidden mr-2">Confirm ✓</button>
                    <button id="undoOfferCancelButton" followup="true" class="action-button cancel check hidden mr-2">✘</button>
                    <button id="undoAcceptButton" followup="true" class="action-button confirm check hidden mr-2">Accept Undo?</button>
                    <button id="undoDenyButton" followup="true" class="action-button cancel check hidden mr-2">✘</button>

                    <button id="resignButton" actions="true" class="action-button confirm mr-2">Resign</button>
                    <button id="resignConfirmButton" followup="true" class="action-button confirm check hidden mr-2">Confirm ✓</button>
                    <button id="resignCancelButton" followup="true" class="action-button cancel check hidden mr-2">✘</button>

                    <button id="drawOfferButton" actions="true" class="action-button confirm mr-2">Draw</button>
                    <button id="drawOfferConfirmButton" followup="true" class="action-button confirm check hidden mr-2">Confirm ✓</button>
                    <button id="drawOfferCancelButton" followup="true" class="action-button cancel check hidden mr-2">✘</button>
                    <button id="drawAcceptButton" followup="true" class="action-button confirm check hidden mr-2">Accept Draw?</button>
                    <button id="drawDenyButton" followup="true" class="action-button cancel check hidden mr-2">✘</button>

                    <button id="cycleThemeButton" class="action-button confirm mr-2">Cycle Theme</button>
                    <button id="flipButton" class="action-button confirm">Flip</button>
                </div>
            </div>
            <script>
                window.addEventListener('load', function() {
                    var iframeContainer = document.getElementById('iframe-container');
                    var width = iframeContainer.offsetWidth;
                    document.getElementById('embedded-iframe').style.height = width + 'px';
                    document.getElementById('command-center').style.height = (width * 0.5) + 'px';
                });
    
                window.addEventListener('resize', function() {
                    var iframeContainer = document.getElementById('iframe-container');
                    var width = iframeContainer.offsetWidth;
                    document.getElementById('embedded-iframe').style.height = width + 'px';
                    document.getElementById('command-center').style.height = (width * 0.5) + 'px';
                });

                function updateCommandCenter() {
                    var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                    var currentGameID = sessionStorage.getItem('current_game_id');
                    currentGameID = (currentGameID === 'null' ? null : currentGameID);
                    if (currentGameID !== null && existingWebGameMetadata.hasOwnProperty(currentGameID)) {
                        var webGameMetadata = existingWebGameMetadata[currentGameID];
                        var moves = webGameMetadata.alg_moves;
                        var movesListContainer = document.getElementById('moves-list');
                        var endState = webGameMetadata.end_state;
    
                        movesListContainer.innerHTML = '';
    
                        for (var i = 0; i < moves.length; i += 2) {
                            var move1 = moves[i];
                            var move2 = (
                                (i + 1 < moves.length) && 
                                moves[i + 1] !== '1-0' && 
                                moves[i + 1] !== '0-1' && 
                                moves[i + 1] !== '½–½'
                            ) ? moves[i + 1] : '';
    
                            var moveRow = document.createElement('div');
                            moveRow.className = 'move-row ' + (i % 4 === 0 ? '' : 'even-move-row');
                            
                            var leftHalf = document.createElement('div');
                            leftHalf.style.width = '50%';
                            leftHalf.textContent = move1;
    
                            var rightHalf = document.createElement('div');
                            rightHalf.style.width = '50%';
                            rightHalf.textContent = move2;
    
                            if (move1 !== '1-0' && move1 !== '0-1' && move1 !== '½–½') {
                                moveRow.appendChild(leftHalf);
                                moveRow.appendChild(rightHalf);
    
                                movesListContainer.appendChild(moveRow);
                            }
    
                        }
    
                        if (endState === "\u00bd\u2013\u00bd") {
                            endState = '½–½'
                        }
                        var forcedEnd = webGameMetadata.forced_end;
                        var endMessagebox = document.getElementById('end-message');
                        var finalScorebox = document.getElementById('final-score');
                        var endmessage = ''
                        if (forcedEnd !== '') {
                            if (forcedEnd === 'Draw by mutual agreement' || forcedEnd === 'Stalemate by Threefold Repetition') {
                                endmessage += forcedEnd;
                                finalScorebox.innerHTML = '½–½';
                            } else {
                                endmessage += forcedEnd + ' • ';
                            }
                        }
    
                        if (endState === '1-0') {
                            endmessage += `White is Triumphant`;
                            endMessagebox.innerHTML = `White is Triumphant`;
                            finalScorebox.innerHTML = '1-0'
                        } else if (endState === '0-1') {
                            endmessage += `Black is Triumphant`;
                            finalScorebox.innerHTML = '0-1'
                        } else if (endState === '½–½' && forcedEnd !== 'Draw by mutual agreement' && forcedEnd !== 'Stalemate by Threefold Repetition') {
                            endmessage += `Stalemate was Reached`;
                            finalScorebox.innerHTML = '½–½'
                        }
    
                        if (endmessage !== '') {
                            endMessagebox.innerHTML = endmessage
                        }
                    }

                }
            
                function resetCommandCenter() {
                    sessionStorage.setItem('current_game_id', null);
                    sessionStorage.setItem('draw_request', 'false');
                    sessionStorage.setItem('undo_request', 'false');

                    var movesListContainer = document.getElementById('moves-list');
                    while (movesListContainer.firstChild) {
                        movesListContainer.removeChild(movesListContainer.firstChild);
                    }

                    var endMessagebox = document.getElementById('end-message');
                    var finalScorebox = document.getElementById('final-score');

                    movesListContainer.innerHTML = "";
                    endMessagebox.innerHTML = ""
                    finalScorebox.innerHTML = ""
                }

                window.addEventListener('load', updateCommandCenter);
                window.addEventListener('load', resetCommandCenter);
            
                setInterval(updateCommandCenter, 100);

                var eventExecutionStatus = {};

                function handleWebtoGameAction(buttonId, localStorageObjectName, Options = null) {
                    var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                    var currentGameID = sessionStorage.getItem('current_game_id');
                    currentGameID = (currentGameID === 'null' ? null : currentGameID);
                    if (currentGameID !== null && existingWebGameMetadata.hasOwnProperty(currentGameID)) { 
                        var webGameMetadata = existingWebGameMetadata[currentGameID];
                        webGameMetadata[localStorageObjectName].execute = true
                        existingWebGameMetadata[currentGameID] = webGameMetadata
                        localStorage.setItem('web_game_metadata', JSON.stringify(existingWebGameMetadata));

                        if (!eventExecutionStatus[localStorageObjectName]) {
                            eventExecutionStatus[localStorageObjectName] = { isExecuting: false, timeoutId: null };
                        }

                        handleActionStatus(buttonId, currentGameID, localStorageObjectName, Options);

                    } else {
                        console.warn("Failed to execute action")
                    }
                }

                function handleActionStatus(buttonId, currentGameID, localStorageObjectName, Options) {
                    var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                    var webGameMetadata = existingWebGameMetadata[currentGameID];
                    var actionCommandStatus = webGameMetadata[localStorageObjectName];
                    
                    // console.log(localStorageObjectName, actionCommandStatus) // Good dev log, very good boy
                    var initialDefaults = (!actionCommandStatus.execute && !actionCommandStatus.update_executed);
                    var optionalReset = false
                    if (actionCommandStatus.hasOwnProperty("reset")) {
                        initialDefaults = initialDefaults && !actionCommandStatus.reset
                        optionalReset = actionCommandStatus.reset
                    }
                    if (!actionCommandStatus.update_executed && optionalReset !== true && !initialDefaults) {
                        eventExecutionStatus[localStorageObjectName].timeoutId = setTimeout(function () {
                            // This can be too fast and execute again right before reset is set to false, 
                            // hence the default condition check
                            handleActionStatus(buttonId, currentGameID, localStorageObjectName, Options);
                        }, 10);
                    } else {
                        webGameMetadata[localStorageObjectName].execute = false
                        webGameMetadata[localStorageObjectName].update_executed = false
                        
                        if (optionalReset === true) {
                            resetButtons(buttonId, localStorageObjectName, Options)
                            webGameMetadata[localStorageObjectName].reset = false
                        }
                        
                        existingWebGameMetadata[currentGameID] = webGameMetadata
                        localStorage.setItem('web_game_metadata', JSON.stringify(existingWebGameMetadata));
                        
                        document.getElementById(buttonId).disabled = false;
                    }
                }

                var inputList = [
                    { buttonId: "undoOfferButton", localStorageObjectName: "undo_move", Options: "followups", action: "undo_request"},
                    { buttonId: "drawOfferButton", localStorageObjectName: "draw_offer", Options: "followups", action: "draw_request" },
                    { buttonId: "resignButton", localStorageObjectName: "resign", Options: "followups"},
                    { buttonId: "cycleThemeButton", localStorageObjectName: "cycle_theme"},
                    { buttonId: "flipButton", localStorageObjectName: "flip_board"},
                ];

                function optionStringsHelper(mainbuttonId, Options) {
                    var approveString = "Confirm";
                    var abandonString = "Cancel";
                    var replaceString = "Button";
                    if (Options === "responses") {
                        approveString = "Accept";
                        abandonString = "Deny";
                        replaceString = "OfferButton"
                    }
                    const buttonApproveId = mainbuttonId.replace(replaceString, approveString + "Button");
                    const buttonAbandonId = mainbuttonId.replace(replaceString, abandonString + "Button");
                    return {ApproveId: buttonApproveId, AbandonID: buttonAbandonId, AbandonStr: abandonString}
                }

                function hideOptions(buttonId, buttonApproveId, buttonAbandonId) {
                    document.getElementById(buttonId).classList.remove("hidden");
                    document.getElementById(buttonApproveId).classList.add("hidden");
                    document.getElementById(buttonAbandonId).classList.add("hidden");
                }

                function resetButtons(mainbuttonId, localStorageObjectName, Options) {
                    result = optionStringsHelper(mainbuttonId, Options)
                    const buttonApproveId = result.ApproveId
                    const buttonAbandonId = result.AbandonID
                    hideOptions(mainbuttonId, buttonApproveId, buttonAbandonId)
                    var matchingInput = inputList.find(item => item.buttonId === mainbuttonId);
                    sessionStorage.setItem(matchingInput["action"], 'false');
                }

                inputList.forEach(function(input) {
                    const optionsValue = (input.hasOwnProperty("Options") ? input.Options: null);
                    document.getElementById(input.buttonId).addEventListener("click", function() {
                        handleButton(input.buttonId, input.localStorageObjectName, optionsValue);
                    });
                });

                var requestChangeTrackers = {};

                function requestDisplay(action, ButtonID, baseStorageName) {
                    var currentValue = JSON.parse(sessionStorage.getItem(action));
                    var currentGameID = sessionStorage.getItem('current_game_id');
                    currentGameID = (currentGameID === 'null' ? null : currentGameID);
                    var resetDisplay = null
                    
                    var newOptions = (currentValue === true ? "responses": "followups")
                    if (currentGameID !== null) {
                        const acceptObjectName = baseStorageName + "_accept"
                        const denyObjectName = baseStorageName + "_deny"
                        var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                        var acceptReset = existingWebGameMetadata[currentGameID][acceptObjectName].reset;
                        var denyReset = existingWebGameMetadata[currentGameID][denyObjectName].reset;
                        resetDisplay = acceptReset || denyReset;
                    }
                    if (currentValue === null || currentValue === requestChangeTrackers[action]) {
                        if (resetDisplay === null || resetDisplay === false) {
                            return;
                        }
                    } else {
                        requestChangeTrackers[action] = currentValue;
                    }
                    
                    if (currentValue === true || resetDisplay === true) {
                        handleButton(ButtonID, baseStorageName, newOptions, resetDisplay, action)
                    }
                }

                setInterval(function() {
                    inputList.forEach(function(request) {
                        if (request.hasOwnProperty('action')) {
                            requestDisplay(request.action, request.buttonId, request.localStorageObjectName);
                        }
                    });
                }, 100);

                function handleButton(buttonId, localStorageObjectName, Options = null, resetDisplay = null, currentAction = null) {
                    document.getElementById(buttonId).disabled = true;
                    if (Options !== null) {
                        result = optionStringsHelper(buttonId, Options)
                        const buttonApproveId = result.ApproveId
                        const buttonAbandonId = result.AbandonID
                        const abandonString = result.AbandonStr
                        const acceptObjectName = localStorageObjectName + "_accept";
                        const denyObjectName = localStorageObjectName + "_deny";
                        if (resetDisplay !== true) {
                            document.getElementById(buttonId).classList.add("hidden");
                            document.getElementById(buttonApproveId).classList.remove("hidden");
                            document.getElementById(buttonAbandonId).classList.remove("hidden");
                            var otherFollowups = document.querySelectorAll('[followup="true"]');
                            otherFollowups.forEach(function(element) {
                                if (element.id !== buttonApproveId && element.id !== buttonAbandonId) {
                                    element.classList.add("hidden");
                                }
                            });
                            var actionbuttons = document.querySelectorAll('[actions="true"]');
                            // var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                            // var currentGameID = sessionStorage.getItem('current_game_id');
                            // var webGameMetadata = existingWebGameMetadata[currentGameID];
                            
                            // this list could be useful though but it's just similar to that is executing one
                            var eventList = [
                                {mainButtonName: "drawOfferButton", eventNames: ["draw_offer", "draw_offer_accept", "draw_offer_deny"]},
                                {mainButtonName: "resignButton", eventNames: ["resign"]},
                                {mainButtonName: "undoButton", eventNames: ["undo_move", "undo_move_accept", "undo_move_deny"]},
                            ]

                            // function eventIsExecuting(obj, eventNames) {
                            //     for (var event in eventNames) {
                            //         if (obj.hasOwnProperty(event) && obj[event]["execute"] === true) {
                            //             return true;
                            //         }
                            //     }
                            //     return false;
                            // }

                            actionbuttons.forEach(function(element) {
                                if (element.id !== buttonId) {
                                    element.classList.remove("hidden");
                                    // This just seems unnecessary after testing
                                    // var actionEvents = eventList.find(event => event.mainButtonName === element.id)
                                    // if (!eventIsExecuting(webGameMetadata, actionEvents.eventNames)) {
                                    //     element.disabled = false;
                                    // }
                                }
                            });
                            document.getElementById(buttonApproveId).addEventListener("click", function() { 
                                hideOptions(buttonId, buttonApproveId, buttonAbandonId)
                                
                                var responseName = (Options === "followups" ? localStorageObjectName : acceptObjectName)
                                
                                handleWebtoGameAction(buttonId, responseName, Options);
                            }, { once: true });
                            document.getElementById(buttonAbandonId).addEventListener("click", function() {
                                hideOptions(buttonId, buttonApproveId, buttonAbandonId)
                                
                                if (abandonString !== "Cancel") {
                                    handleWebtoGameAction(buttonId, denyObjectName, Options);
                                }
                                
                                document.getElementById(buttonId).disabled = false;
                            }, { once: true });
                        } else {
                            hideOptions(buttonId, buttonApproveId, buttonAbandonId)

                            var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                            var currentGameID = sessionStorage.getItem('current_game_id');
                            var webGameMetadata = existingWebGameMetadata[currentGameID];
                            webGameMetadata[localStorageObjectName].reset = false;
                            webGameMetadata[acceptObjectName].reset = false;
                            webGameMetadata[denyObjectName].reset = false;
                            existingWebGameMetadata[currentGameID] = webGameMetadata;
                            
                            sessionStorage.setItem(currentAction, 'false');
                            localStorage.setItem('web_game_metadata', JSON.stringify(existingWebGameMetadata));
                            document.getElementById(buttonId).disabled = false;
                        }
                    } else {
                        handleWebtoGameAction(buttonId, localStorageObjectName)
                    };
                }

                // // Logging Debug python console messages; Only for development hence keep it commented. Maybe add a global dev flag too
                // function pythonDebugLogger() {
                //     var logs = webGameMetadata.console_messages
                //     for (var i = 0; i < logs.length; i++) {
                //         console.log(logs[i])
                //     }
                // }

                // window.addEventListener('load', pythonDebugLogger);
            
                // // Set up an interval to log debug print statements
                // setInterval(pythonDebugLogger, 1000);
            </script>
        </div>
    </div>
</div>
{% endblock %}

{% block footer %}
{% endblock %}