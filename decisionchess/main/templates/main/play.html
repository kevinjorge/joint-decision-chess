{% extends "main/base.html" %}

{% load static %}

{% block title %}
Play
{% endblock %}

{% block style%}
<style>
    .homeblock {
        height: 5%;
    }

    .sidenav {
        height: 95%;
    }

    #iframe-container {
        position: relative;
        width: 100%;
    }
    #embedded-iframe {
        width: 100%;
    }

    .scrollable-moves-list {
        overflow-y: scroll;
        max-height: 40%; /* 10% above for the username later */
    }
    
    .action-button {
        border: none;
        outline: none;
        background-color: transparent;
        transition: background-color 0.3s ease;
        color: white;
    }

    .action-button:focus {
        outline: none;
    }

    .action-button.confirm.check {
        background-color: #6f9176;
    }

    .action-button.confirm:hover {
        background-color: #449255;
    }

    .action-button.confirm:disabled:hover {
        background-color: #da8525;
    }

    .action-button.confirm.waiting:disabled:hover {
        background-color: #c7c7c7;
        color: #4d4d4d;
    }

    .action-button.cancel.check {
        background-color: rgb(161, 160, 85);
    }

    .action-button.cancel:hover {
        background-color: #a05139;
    }

    .hidden {
        display: none;
    }

    .move-row {
        display: flex;
    }

    .move-row > div {
        width: 50%;
    }

    .even-move-row {
        background-color: rgb(150, 150, 150);
    }
</style>
<script>
    var existingWebGameMetadata = localStorage.getItem('web_game_metadata');
    if (existingWebGameMetadata == null) {
        var webGameMetadata = {};
        localStorage.setItem('web_game_metadata', JSON.stringify(webGameMetadata));
    }
</script>
{% endblock %}

{% block content %}
<div id="content", name="content", class="content">
    <div class="row justify-content-center" style="max-width: 100%;"> <!-- max width necessary for no horizontal scrolling -->
        <!-- Given side bar maybe columns should instead be 3 5 3  and side bar width is a column width-->
        <!-- 3 columns for chat and notes -->
        <!-- Consider if this col-5 should be present for all play views or just the main one-->
        <!-- That is we can embedd the game itself in here as it's own template maybe -->
        <div class="col-5">
            <div id="iframe-container">
                <iframe id="embedded-iframe" src="{% static 'main/html/game.html' %}" frameborder=0 scrolling="no"></iframe>
            </div>
        </div>
        <!-- 3 columns for command center-->
        <div class="col-3 d-flex align-items-center">
            <div id="command-center" class="bg-secondary d-flex flex-column align-items-center justify-content-center" style="min-width: 100%;">
                <!-- Content will be dynamically added here -->
                <div id="moves-list" class="scrollable-moves-list" style="min-width: 100%;">
                    <!-- Content will be dynamically added here -->
                </div>
                <div id="final-score" class="text-white font-weight-bold text-lg mt-2"></div>
                <div id="end-message" class="text-white"></div>
                <div class="d-flex justify-content-center">
                    <!-- Need a button class here -->
                    <button id="undoOfferButton" actions="true" class="action-button confirm mr-2">Undo</button>
                    <button id="undoOfferConfirmButton" followup="true" class="action-button confirm check hidden mr-2">Confirm ✓</button>
                    <button id="undoOfferCancelButton" followup="true" class="action-button cancel check hidden mr-2">✘</button>
                    <button id="undoAcceptButton" followup="true" class="action-button confirm check hidden mr-2">Accept Undo?</button>
                    <button id="undoDenyButton" followup="true" class="action-button cancel check hidden mr-2">✘</button>

                    <button id="resignButton" actions="true" class="action-button confirm mr-2">Resign</button>
                    <button id="resignConfirmButton" followup="true" class="action-button confirm check hidden mr-2">Confirm ✓</button>
                    <button id="resignCancelButton" followup="true" class="action-button cancel check hidden mr-2">✘</button>

                    <button id="drawOfferButton" actions="true" class="action-button confirm mr-2">Draw</button>
                    <button id="drawOfferConfirmButton" followup="true" class="action-button confirm check hidden mr-2">Confirm ✓</button>
                    <button id="drawOfferCancelButton" followup="true" class="action-button cancel check hidden mr-2">✘</button>
                    <button id="drawAcceptButton" followup="true" class="action-button confirm check hidden mr-2">Accept Draw?</button>
                    <button id="drawDenyButton" followup="true" class="action-button cancel check hidden mr-2">✘</button>

                    <button id="cycleThemeButton" class="action-button confirm mr-2">Cycle Theme</button>
                    <button id="flipButton" class="action-button confirm">Flip</button>
                </div>
            </div>
            <script>
                window.addEventListener('load', function() {
                    var iframeContainer = document.getElementById('iframe-container');
                    var width = iframeContainer.offsetWidth;
                    document.getElementById('embedded-iframe').style.height = width + 'px';
                    document.getElementById('command-center').style.height = (width * 0.5) + 'px';
                });
    
                window.addEventListener('resize', function() {
                    var iframeContainer = document.getElementById('iframe-container');
                    var width = iframeContainer.offsetWidth;
                    document.getElementById('embedded-iframe').style.height = width + 'px';
                    document.getElementById('command-center').style.height = (width * 0.5) + 'px';
                });

                function updateCommandCenter() {
                    var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                    var currentGameID = sessionStorage.getItem('current_game_id');
                    currentGameID = (currentGameID === 'null' ? null : currentGameID);
                    if (currentGameID !== null && existingWebGameMetadata.hasOwnProperty(currentGameID)) {
                        var webGameMetadata = existingWebGameMetadata[currentGameID];
                        var moves = webGameMetadata.alg_moves;
                        var movesListContainer = document.getElementById('moves-list');
                        var endState = webGameMetadata.end_state;
    
                        movesListContainer.innerHTML = '';
    
                        for (var i = 0; i < moves.length; i += 2) {
                            var move1 = moves[i];
                            var move2 = (
                                (i + 1 < moves.length) && 
                                moves[i + 1] !== '1-0' && 
                                moves[i + 1] !== '0-1' && 
                                moves[i + 1] !== '½–½'
                            ) ? moves[i + 1] : '';
    
                            var moveRow = document.createElement('div');
                            moveRow.className = 'move-row ' + (i % 4 === 0 ? '' : 'even-move-row');
                            
                            var leftHalf = document.createElement('div');
                            leftHalf.style.width = '50%';
                            leftHalf.textContent = move1;
    
                            var rightHalf = document.createElement('div');
                            rightHalf.style.width = '50%';
                            rightHalf.textContent = move2;
    
                            if (move1 !== '1-0' && move1 !== '0-1' && move1 !== '½–½') {
                                moveRow.appendChild(leftHalf);
                                moveRow.appendChild(rightHalf);
    
                                movesListContainer.appendChild(moveRow);
                            }
    
                        }
    
                        if (endState === "\u00bd\u2013\u00bd") {
                            endState = '½–½'
                        }
                        var forcedEnd = webGameMetadata.forced_end;
                        var endMessagebox = document.getElementById('end-message');
                        var finalScorebox = document.getElementById('final-score');
                        var endmessage = ''
                        if (forcedEnd !== '') {
                            if (forcedEnd === 'Draw by mutual agreement' || forcedEnd === 'Stalemate by Threefold Repetition') {
                                endmessage += forcedEnd;
                                finalScorebox.innerHTML = '½–½';
                            } else {
                                endmessage += forcedEnd + ' • ';
                            }
                        }
    
                        if (endState === '1-0') {
                            endmessage += `White is Triumphant`;
                            endMessagebox.innerHTML = `White is Triumphant`;
                            finalScorebox.innerHTML = '1-0'
                        } else if (endState === '0-1') {
                            endmessage += `Black is Triumphant`;
                            finalScorebox.innerHTML = '0-1'
                        } else if (endState === '½–½' && forcedEnd !== 'Draw by mutual agreement' && forcedEnd !== 'Stalemate by Threefold Repetition') {
                            endmessage += `Stalemate was Reached`;
                            finalScorebox.innerHTML = '½–½'
                        }
    
                        if (endmessage !== '') {
                            endMessagebox.innerHTML = endmessage
                        }
                    }

                }
            
                function resetCommandCenter() {
                    var movesListContainer = document.getElementById('moves-list');
                    while (movesListContainer.firstChild) {
                        movesListContainer.removeChild(movesListContainer.firstChild);
                    }

                    var endMessagebox = document.getElementById('end-message');
                    var finalScorebox = document.getElementById('final-score');

                    movesListContainer.innerHTML = "";
                    endMessagebox.innerHTML = ""
                    finalScorebox.innerHTML = ""
                }

                var game_uuid = "{{ game_uuid }}";
                sessionStorage.setItem('connected', "{{ connected }}");
                sessionStorage.setItem('current_game_id', "{{ current_game_id }}");
                sessionStorage.setItem('initialized', "{{ initialized }}");
                sessionStorage.setItem('draw_request', "{{ draw_request }}");
                sessionStorage.setItem('undo_request', "{{ undo_request }}");
                sessionStorage.setItem('total_reset', "{{ total_reset }}");

                var previousConnected = false

                window.addEventListener('load', resetCommandCenter);
                window.addEventListener('load', updateCommandCenter);
            
                setInterval(updateCommandCenter, 100);

                var csrftoken = Cookies.get('csrftoken');

                function updateConnectedStatus(status) {
                    fetch('/update_connected/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrftoken,
                            },
                            body: JSON.stringify({ 
                                game_uuid: game_uuid, 
                                web_connect: status
                            }),
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === "error" && data.message === "Lobby row DNE") {
                                return;
                            }
                            // Handle the response as needed
                            // Put in a "waiting message" if it hasn't been played yet
                            // Put a disconnect status if in play
                        })
                        .catch(error => {
                            console.error('Error updating connection status:', error);
                        });
                }

                function checkNewConnect() {
                    var currentConnected = sessionStorage.getItem('connected');
                    currentConnected = (currentConnected === 'true' ? true : false);
                    if (currentConnected === true && previousConnected === false) {
                        updateConnectedStatus(true)
                    }
                    
                    previousConnected = currentConnected;
                }
                
                setInterval(checkNewConnect, 1000);

                window.onbeforeunload = function (e) {
                    var confirmationMessage = 'You have unsaved changes. Are you sure you want to leave this page?';
                    e.returnValue = confirmationMessage; // For legacy browsers
                    return confirmationMessage;

                    var userConfirmed = confirm(confirmationMessage);
                    if (userConfirmed) {
                        updateConnectedStatus(false); // This simply won't work so we'll just need web-sockets
                    }
                };
                
                window.addEventListener('beforeunload', function () {
                    sessionStorage.setItem('connected', 'false');
                    sessionStorage.setItem('current_game_id', game_uuid);
                    sessionStorage.setItem('initialized', 'null');
                    sessionStorage.setItem('draw_request', 'false');
                    sessionStorage.setItem('undo_request', 'false');
                    sessionStorage.setItem('total_reset', 'false');
                });

                var eventExecutionStatus = {};

                function handleWebtoGameAction(buttonId, localStorageObjectName, Options = null) {
                    var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                    var currentGameID = sessionStorage.getItem('current_game_id');
                    currentGameID = (currentGameID === 'null' ? null : currentGameID);
                    if (currentGameID !== null && existingWebGameMetadata.hasOwnProperty(currentGameID)) { 
                        var webGameMetadata = existingWebGameMetadata[currentGameID];
                        webGameMetadata[localStorageObjectName].execute = true
                        existingWebGameMetadata[currentGameID] = webGameMetadata
                        localStorage.setItem('web_game_metadata', JSON.stringify(existingWebGameMetadata));

                        if (!eventExecutionStatus[localStorageObjectName]) {
                            eventExecutionStatus[localStorageObjectName] = { isExecuting: false, timeoutId: null };
                        }

                        handleActionStatus(buttonId, currentGameID, localStorageObjectName, Options);

                    } else {
                        console.warn("Failed to execute action")
                    }
                }

                // This is filled in the handleButton function later
                var offerQueue = [];
                function dequeButton(mainButtonId) {
                    return new Promise((resolve, reject) => { 
                        offerQueue = offerQueue.filter(item => item.mainId !== mainButtonId);
                        resolve(offerQueue);
                    });
                }

                var offerEventList = [
                    {mainButtonName: "drawOfferButton", eventNames: ["draw_offer", "draw_offer_accept", "draw_offer_deny"]},
                    {mainButtonName: "undoOfferButton", eventNames: ["undo_move", "undo_move_accept", "undo_move_deny"]},
                ]

                var actionEventList = [
                    {mainButtonName: "drawOfferButton", eventNames: ["draw_offer", "draw_offer_accept", "draw_offer_deny"]},
                    {mainButtonName: "undoOfferButton", eventNames: ["undo_move", "undo_move_accept", "undo_move_deny"]},
                    {mainButtonName: "resignButton", eventNames: ["resign"]}
                ]

                var inputList = [
                    { buttonId: "undoOfferButton", localStorageObjectName: "undo_move", Options: "followups", action: "undo_request"},
                    { buttonId: "drawOfferButton", localStorageObjectName: "draw_offer", Options: "followups", action: "draw_request" },
                    { buttonId: "resignButton", localStorageObjectName: "resign", Options: "followups"},
                    { buttonId: "cycleThemeButton", localStorageObjectName: "cycle_theme"},
                    { buttonId: "flipButton", localStorageObjectName: "flip_board"},
                ];

                function handleActionStatus(buttonId, currentGameID, localStorageObjectName, Options) {
                    var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                    var webGameMetadata = existingWebGameMetadata[currentGameID];
                    var actionCommandStatus = webGameMetadata[localStorageObjectName];
                    
                    // console.log(localStorageObjectName, actionCommandStatus) // Good dev log, very good boy
                    var initialDefaults = (!actionCommandStatus.execute && !actionCommandStatus.update_executed);
                    var optionalReset = false
                    if (actionCommandStatus.hasOwnProperty("reset")) {
                        initialDefaults = initialDefaults && !actionCommandStatus.reset
                        optionalReset = actionCommandStatus.reset
                    }
                    if (!actionCommandStatus.update_executed && optionalReset !== true && !initialDefaults) {
                        eventExecutionStatus[localStorageObjectName].timeoutId = setTimeout(function () {
                            // This can be too fast and execute again right before reset is set to false, 
                            // hence the default condition check
                            handleActionStatus(buttonId, currentGameID, localStorageObjectName, Options);
                        }, 10);
                    } else {
                        var accept_response_sent = localStorageObjectName.includes("accept") && webGameMetadata[localStorageObjectName].update_executed
                        webGameMetadata[localStorageObjectName].execute = false
                        webGameMetadata[localStorageObjectName].update_executed = false
                        
                        if (optionalReset === true) {
                            resetButtons(buttonId, localStorageObjectName, Options)
                            webGameMetadata[localStorageObjectName].reset = false
                        }
                        var totalReset = JSON.parse(sessionStorage.getItem("total_reset"));
                        if (totalReset) {
                            // Need to reset all active offer buttons
                            offerEventList.forEach(function(event) {
                                for (var i = 0; i < event.eventNames.length; i++) {
                                    var subevent = event.eventNames[i];
                                    var subOptions = i === 0 ? "followups" : "responses";
                                    document.getElementById(event.mainButtonName).classList.remove("waiting")
                                    document.getElementById(event.mainButtonName).disabled = false
                                    resetButtons(event.mainButtonName, subevent, subOptions)
                                }
                            });
                            sessionStorage.setItem("total_reset", 'false')
                        }
                        // We don't want to clear the offer queue on follow-ups or simple client actions or deny (individual resets)
                        // Only on accepts, main actions accepts, and total resets
                        var offer_accepted_received = offerEventList.some(item => item.eventNames[0] === localStorageObjectName)
                        if (accept_response_sent || offer_accepted_received || totalReset) {
                            offerQueue = [];
                        }

                        existingWebGameMetadata[currentGameID] = webGameMetadata
                        localStorage.setItem('web_game_metadata', JSON.stringify(existingWebGameMetadata));
                        
                        document.getElementById(buttonId).disabled = false;
                    }
                }

                function optionStringsHelper(mainbuttonId, Options) {
                    var approveString = "Confirm";
                    var abandonString = "Cancel";
                    var replaceString = "Button";
                    if (Options === "responses") {
                        approveString = "Accept";
                        abandonString = "Deny";
                        replaceString = "OfferButton"
                    }
                    const buttonApproveId = mainbuttonId.replace(replaceString, approveString + "Button");
                    const buttonAbandonId = mainbuttonId.replace(replaceString, abandonString + "Button");
                    return {ApproveId: buttonApproveId, AbandonId: buttonAbandonId, AbandonStr: abandonString}
                }

                function hideOptions(buttonId, buttonApproveId, buttonAbandonId) {
                    document.getElementById(buttonId).classList.remove("hidden");
                    document.getElementById(buttonApproveId).classList.add("hidden");
                    document.getElementById(buttonAbandonId).classList.add("hidden");
                }

                function showOptions(buttonId, buttonApproveId, buttonAbandonId) {
                    document.getElementById(buttonId).classList.add("hidden");
                    document.getElementById(buttonApproveId).classList.remove("hidden");
                    document.getElementById(buttonAbandonId).classList.remove("hidden");
                }

                function resetButtons(mainbuttonId, localStorageObjectName, Options) {
                    result = optionStringsHelper(mainbuttonId, Options)
                    const buttonApproveId = result.ApproveId
                    const buttonAbandonId = result.AbandonId
                    hideOptions(mainbuttonId, buttonApproveId, buttonAbandonId)
                    var matchingInput = inputList.find(item => item.buttonId === mainbuttonId);
                    sessionStorage.setItem(matchingInput["action"], 'false');
                }

                inputList.forEach(function(input) {
                    const optionsValue = (input.hasOwnProperty("Options") ? input.Options: null);
                    document.getElementById(input.buttonId).addEventListener("click", function() {
                        handleButton(input.buttonId, input.localStorageObjectName, optionsValue);
                    });
                });

                var requestChangeTrackers = {};

                function requestDisplay(action, ButtonID, baseStorageName) {
                    var currentValue = JSON.parse(sessionStorage.getItem(action));
                    var currentGameID = sessionStorage.getItem('current_game_id');
                    var initialized = sessionStorage.getItem('initialized');
                    currentGameID = (currentGameID === 'null' ? null : currentGameID);
                    initialized = (initialized === 'true' ? true : null);
                    var resetDisplay = null
                    
                    var newOptions = (currentValue === true ? "responses": "followups")
                    // Sometimes it gets to this block even though web_game_metadata isn't set somehow, old values or failure to set in script?
                    // It must be old session values so the reset function isn't running...
                    if (currentGameID !== null && initialized === true) {
                        const acceptObjectName = baseStorageName + "_accept"
                        const denyObjectName = baseStorageName + "_deny"
                        var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                        var acceptReset = existingWebGameMetadata[currentGameID][acceptObjectName].reset;
                        var denyReset = existingWebGameMetadata[currentGameID][denyObjectName].reset;
                        var totalReset = JSON.parse(sessionStorage.getItem("total_reset"));
                        resetDisplay = acceptReset || denyReset || totalReset;
                    }
                    if (currentValue === null || currentValue === requestChangeTrackers[action]) {
                        if (resetDisplay === null || resetDisplay === false) {
                            return;
                        }
                    } else {
                        requestChangeTrackers[action] = currentValue;
                    }
                    
                    if (currentValue === true || resetDisplay === true) {
                        handleButton(ButtonID, baseStorageName, newOptions, resetDisplay, action)
                    }
                }

                setInterval(function() {
                    inputList.forEach(function(request) {
                        if (request.hasOwnProperty('action')) {
                            requestDisplay(request.action, request.buttonId, request.localStorageObjectName);
                        }
                    });
                }, 100);

                function eventIsExecuting(obj, eventNames) {
                    for (var event of eventNames) {
                        if (obj.hasOwnProperty(event) && obj[event]["execute"] === true) {
                            return true;
                        }
                    }
                    return false;
                }

                function showNewOptions(offerQueue) {
                    if (offerQueue.length !== 0) {
                        var newDisplay = offerQueue[0];
                        showOptions(newDisplay.mainId, newDisplay.ApproveId, newDisplay.AbandonId)
                    }
                }

                function handleButton(buttonId, localStorageObjectName, Options = null, resetDisplay = null, currentAction = null) {
                    document.getElementById(buttonId).disabled = true;
                    if (Options !== null) {
                        result = optionStringsHelper(buttonId, Options)
                        const buttonApproveId = result.ApproveId
                        const buttonAbandonId = result.AbandonId
                        const abandonString = result.AbandonStr
                        const acceptObjectName = localStorageObjectName + "_accept";
                        const denyObjectName = localStorageObjectName + "_deny";
                        if (resetDisplay !== true) {
                            document.getElementById(buttonId).classList.add("hidden");
                            document.getElementById(buttonApproveId).classList.remove("hidden");
                            document.getElementById(buttonAbandonId).classList.remove("hidden");
                            var otherFollowups = document.querySelectorAll('[followup="true"]');
                            if (Options === "responses") {
                                document.getElementById(buttonId).classList.add("waiting")
                                offerQueue.push({mainId: buttonId, ApproveId: buttonApproveId, AbandonId: buttonAbandonId})
                            }
                            otherFollowups.forEach(function(element) {
                                if (element.id !== buttonApproveId && element.id !== buttonAbandonId) {
                                    element.classList.add("hidden");
                                }
                            });
                            var actionbuttons = document.querySelectorAll('[actions="true"]');
                            var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                            var currentGameID = sessionStorage.getItem('current_game_id');
                            var webGameMetadata = existingWebGameMetadata[currentGameID];
                            
                            actionbuttons.forEach(function(element) {
                                if (element.id !== buttonId) {
                                    element.classList.remove("hidden");
                                    var actionEvents = actionEventList.find(event => event.mainButtonName === element.id)
                                    var notQueued = offerQueue.every(item => item.mainId !== element.id)
                                    var notExecuting = !eventIsExecuting(webGameMetadata, actionEvents.eventNames)
                                    if (notExecuting && notQueued) {
                                        element.disabled = false;
                                    }
                                }
                            });
                            document.getElementById(buttonApproveId).addEventListener("click", function() { 
                                hideOptions(buttonId, buttonApproveId, buttonAbandonId)
                                if (Options === "responses") {
                                    document.getElementById(buttonId).classList.remove("waiting")
                                    dequeButton(buttonId)
                                        .then(updatedQueue => {
                                        offerQueue = updatedQueue;
                                        showNewOptions(offerQueue);
                                        });
                                } else {
                                    showNewOptions(offerQueue)
                                }
                                
                                var responseName = (Options === "followups" ? localStorageObjectName : acceptObjectName)
                                
                                handleWebtoGameAction(buttonId, responseName, Options);
                            }, { once: true });
                            document.getElementById(buttonAbandonId).addEventListener("click", function() {
                                hideOptions(buttonId, buttonApproveId, buttonAbandonId)
                                if (Options === "responses") {
                                    document.getElementById(buttonId).classList.remove("waiting")
                                    dequeButton(buttonId)
                                        .then(updatedQueue => {
                                        offerQueue = updatedQueue;
                                        showNewOptions(offerQueue);
                                        });
                                } else {
                                    showNewOptions(offerQueue)
                                }
                                
                                if (abandonString !== "Cancel") {
                                    handleWebtoGameAction(buttonId, denyObjectName, Options);
                                }
                                document.getElementById(buttonId).disabled = false;
                            }, { once: true });
                        } else {
                            hideOptions(buttonId, buttonApproveId, buttonAbandonId)
                            // We should not call the second block given a total reset, previously it was first in order but the response was delayed.
                            // Hence, it showed the next queued item after the totalReset already hid it
                            var totalReset = JSON.parse(sessionStorage.getItem("total_reset"));
                            if (totalReset) {
                                offerQueue = [];
                                // Need to reset all displayed offer buttons
                                offerEventList.forEach(function(event) {
                                    for (var i = 0; i < event.eventNames.length; i++) {
                                        document.getElementById(event.mainButtonName).classList.remove("waiting");
                                        document.getElementById(event.mainButtonName).disabled = false;
                                        var subevent = event.eventNames[i];
                                        var subOptions = i === 0 ? "followups" : "responses";
                                        resetButtons(event.mainButtonName, subevent, subOptions)
                                    }
                                });
                                sessionStorage.setItem("total_reset", 'false')
                            } else if (Options === "responses") {
                                document.getElementById(buttonId).classList.remove("waiting")
                                dequeButton(buttonId)
                                    .then(updatedQueue => {
                                    offerQueue = updatedQueue;
                                    showNewOptions(offerQueue);
                                    });
                            } else {
                                showNewOptions(offerQueue)
                            }

                            var existingWebGameMetadata = JSON.parse(localStorage.getItem('web_game_metadata'));
                            var currentGameID = sessionStorage.getItem('current_game_id');
                            var webGameMetadata = existingWebGameMetadata[currentGameID];
                            webGameMetadata[localStorageObjectName].reset = false;
                            webGameMetadata[acceptObjectName].reset = false;
                            webGameMetadata[denyObjectName].reset = false;
                            existingWebGameMetadata[currentGameID] = webGameMetadata;
                            
                            sessionStorage.setItem(currentAction, 'false');
                            localStorage.setItem('web_game_metadata', JSON.stringify(existingWebGameMetadata));
                            document.getElementById(buttonId).disabled = false;
                        }
                    } else {
                        handleWebtoGameAction(buttonId, localStorageObjectName)
                    };
                }

                // // Logging Debug python console messages; Only for development hence keep it commented. Maybe add a global dev flag too
                // function pythonDebugLogger() {
                //     var logs = webGameMetadata.console_messages
                //     for (var i = 0; i < logs.length; i++) {
                //         console.log(logs[i])
                //     }
                // }

                // window.addEventListener('load', pythonDebugLogger);
            
                // // Set up an interval to log debug print statements
                // setInterval(pythonDebugLogger, 1000);
            </script>
        </div>
    </div>
</div>
{% endblock %}

{% block footer %}
{% endblock %}